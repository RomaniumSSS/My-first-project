# Техническая документация

## 1. Системная архитектура

Проект построен как модульный Telegram-бот с использованием асинхронной архитектуры. Он следует многоуровневому дизайну для разделения представления (взаимодействие с Telegram), бизнес-логики (Коучинг/Цели) и сохранения данных.

### Высокоуровневые компоненты
-   **Bot Service (Сервис бота)**: Обрабатывает взаимодействия с пользователем, команды и маршрутизацию сообщений.
-   **Application Logic (Логика приложения)**: Содержит основные бизнес-правила для отслеживания целей, геймификации и уровней пользователей.
-   **AI Service (ИИ-сервис)**: Интерфейс для взаимодействия с Большой Языковой Моделью (LLM) для анализа целей и генерации советов по коучингу.
-   **Database (База данных)**: Постоянное хранилище для пользователей, целей, журналов прогресса и подписок.
-   **Scheduler (Планировщик)**: Фоновый сервис для обработки повторяющихся задач, таких как напоминания, чек-ины и еженедельные сводки.

## 2. Технологический стек

### Ядро
-   **Язык**: Python (AsyncIO)
-   **Фреймворк бота**: `aiogram` (Асинхронный фреймворк для Telegram Bot API)

### Данные и хранение
-   **База данных**: PostgreSQL (Реляционные данные для структурированных данных пользователей/целей)
-   **ORM**: SQLAlchemy (Async) для взаимодействия с базой данных
-   **Миграции**: Alembic
-   **In-Memory хранилище**: Redis (Используется для управления состоянием FSM, кэширования и троттлинга)

### ИИ и обработка
-   **Провайдер LLM**: OpenAI API (или совместимый) для анализа текста и возможностей зрения (мудборды).
-   **Обработка изображений**: Стандартные библиотеки для обработки загруженных пользователем фото перед анализом.

### Инфраструктура
-   **Контейнеризация**: Docker и Docker Compose
-   **Планирование**: `APScheduler` (или нативные задачи asyncio) для событий, основанных на времени.

## 3. Структура проекта

Кодовая база организована для содействия разделению ответственности:

-   `src/bot/`: Логика, специфичная для Telegram.
    -   `handlers/`: Обработчики сообщений и колбэков, сгруппированные по функциям (онбординг, цели, отслеживание).
    -   `keyboards/`: Определения инлайн и reply клавиатур.
    -   `middlewares/`: Этапы обработки для каждого запроса (авторизация, логирование, троттлинг).
    -   `states/`: Определения FSM (Конечный Автомат) для многошаговых диалогов.
-   `src/database/`: Слоку данных.
    -   `models/`: Определения моделей SQLAlchemy.
    -   `repositories/`: Паттерны доступа к данным (операции CRUD).
-   `src/services/`: Бизнес-логика, отделенная от интерфейса бота.
    -   `llm_service/`: Логика промптов и взаимодействия с API.
    -   `gamification/`: Логика для расчета очков, уровней и серий (стриков).
    -   `payment/`: Интеграция для обработки подписок.

## 4. Ключевые технические потоки

### 4.1. Онбординг и оценка пользователя
1.  Пользователь запускает бота -> Состояние FSM инициализируется в Redis.
2.  Бот собирает входные данные (текст/изображения) через Handlers (Обработчики).
3.  Данные агрегируются и отправляются в `LLM Service`.
4.  Результирующий профиль сохраняется в PostgreSQL.

### 4.2. Цикл ИИ-коучинга
1.  Пользователь отправляет цель/обновление.
2.  `LLM Service` формирует промпт с контекстом пользователя (история, личность).
3.  Ответ LLM парсится и форматируется.
4.  Бот отправляет ответ + обновляет статистику геймификации в базе данных.

### 4.3. Уведомления и напоминания
1.  Планировщик срабатывает периодически.
2.  Запрашивает базу данных для пользователей с ожидающими напоминаниями (учитывая часовые пояса).
3.  Отправляет сообщения через Bot API.

## 5. Внешние интеграции
-   **Telegram Bot API**: Интерфейс основной платформы.
-   **LLM Provider API**: Бэкенд интеллекта.
-   **Payment Gateway**: (Будущая реализация для уровня Premium).

## 6. Безопасность и масштабируемость
-   **Переменные окружения**: Чувствительные ключи (API токены, учетные данные БД) управляются через `.env`.
-   **Асинхронность**: Полностью асинхронный ввод/вывод для эффективной обработки множества одновременных пользователей.
-   **Пул соединений**: Соединения с БД управляются через пул для предотвращения исчерпания ресурсов.
